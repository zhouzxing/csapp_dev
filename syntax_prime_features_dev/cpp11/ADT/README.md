# 专项训练-通用例程
> 协会：语言、标准
> 找到应用场景

## 表-栈-队列

* 表的实现结构
    
    - 数组 : 插入、删除的线性； 初始大小问题
    
    - 链表 | 双链表 | 循环双链表 |  : 
        + 虚拟头节点
        * 虚拟游标模拟[待考证-不同系统支持指针语法]

* 栈 <- 计算机结构决定性能取舍
    - FILO : Stack 插入元素，正好跟常规链表相反的方向
    - 应用：平衡符号、后缀表达式[O(N),忽略优先规则]、函数调用

* 队列
    - FIFO :
    - 图论


## 树 
> Olog(N)解决链表O(N)

* 应用：FS-类树，

* 二叉树
    - 编译器领域：简单表达式树 [先序|中序|后序-对应根节点&左右子节点顺序] - 操作符
    - 二叉查找树[ADT] -查找应用 O(logN)
        * 约束：Left < Root < Right
        * 结论：左子树即最小值，右子树即最大值 [复杂度：构建ADT]
        * 抽象：三种情况
            - 常用删除策略：右子树最小数据替代 [实现最少的改动原有结构] -这东西：深度思考设计过！
            - 其他策略：懒惰删除[删除情况较少，打标签] - 算法的本质：迭代优化！
    - AVL树
        * 约束：平衡条件的二叉查找树 [左子树&右子树高度差=1]
        * 抽象：S(h) = S(h-1) + S(h-2) + 1,S(0)=1,S(1)=2
        * 实现：旋转 -> 2种情况的抽象 ：找规律[固化流程]
            * 关键节点：出问题：层高超过2的节点，旋转父子
            * 找到扰动的父节点，进行微调为原则
            * 证明：
                - SingleRotate(A) => A.left.right = A
                - DoubleRotate(A) => A.left.right.left = A.left
                    A.left.right.right = A
                    => A.left = sr(A.left) ; sr(A)
            * 删除问题，高度问题
                - [研究的应用场景缺乏-进一步找到实战的场地！]
    - 伸展树
        * dd
> con: 层序遍历 - 队列; 前中后序 - 栈

* B-树
 [DB_Engine] M：3&4-内存；存储盘：[32-,256]
    - LSM树
    - B+树

## 散列
- 装载因子：lambda, 元素实际个数/容器容量
- hash 与 hash冲突:
    + hash函数：mod & 素数 [数组]
    + 分离链接：链表
    + 开放地址法：线性探测 || 平方探测法 || 双散列
- 其他：再散列、可扩散列 [？应用场景]

## 优先队列[堆]
- 简单实现：简单链表，头部插入，删除最小O(N)

- 二叉堆[满二叉树]
    + 建堆：
    + 插入，删除 [推论：index(chile) / 2 = index(parent)]
- 其他： D堆 & 斜堆 || 二项队列 [缺应用场景]

## 排序

- 平均互逆数： N(N-1)/4
- 证明：考研数学功底！[足够重视]
- 


