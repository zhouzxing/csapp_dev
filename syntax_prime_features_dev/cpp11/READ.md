# C++98/03 & C++11
> 结构化编程：[编译器实现||规定/标准/定义]

## 细节知识点整理

* C++ main() 的 启动代码-编译器如何启动main()
* OS 内核的启动代码 || 机器语言部分的引导程序
* Java 程序的主引导程序，JVM-BootStrap

### 数据标识
- 符号类型
- 字面值
- [统称：算术类型-整数 & 浮点型]
- 数组|结构|指针[union|enum|string|array/vector]
- 


### 版本号区别 - C++实现源码[编译器-校验表...]

- GNU GCC
- g++
- Borland C++
- C++翻译器
- 
- ANSI C || K&R C || C++11...
- 

### 内存管理
- 自动存储[代码块] - 栈
- 静态存储[全局/static] - 
- 动态存储[new/delete] - 堆-内存池[智能指针]
- 引用变量 || 指针
    - 强制转换规则
        - 类型强制转换
        - 引用类型不可以强转？
- 问题：静态无连接 & 静态内部链接 什么区别？
    + 无连接限制作用域未函数快，那静态的意义在哪儿？[生命周期] -[多占用内存的意义在哪儿？] -[默认初始值：0]
    + 自动变量未知，不确定[]


## 模板类库

- array || string || vector
-

> - 整理一遍核心语言特征 - 熟悉|认识编译器实现本质！
> - 解决根源：走到这一步的根深蒂固的思想|见识|资源，全力打破一个角的破局！
> - 项目经验+语法过一遍[细节太多，看起来很慢-本身工作量的合理评估！]
>   + 历史迭代优化 <- 心血|| 投入与成绩
>   + 类的出现：源于过程性编程 -> 管理大型代码、命名空间，生命周期
>   + 类应用 -> ADT <- struct


## QA
> 目标：做项目，拿资源，搞产品，奠定行业影响力！

- 引用不占空间,如何实现的呢？[区别指针占用一定空间]-编译器实现有关
- double : .5D/d?
- 左值引用，右值引用，万能引用 || 区别指针，万能指针
    + 赋值构造 || 左值引用
    + 
- 类型转换规则：内置?
    + char | short -> int -> unsigned ->long -> double
    + float -> double
    + 友元函数 || 自定义类转换函数 | 构造 || 运算符重载
- std:: 如何实现类库动态加载的 [#include][命名空间还不熟悉]
    + 实现多个库的同一个命名名称
- 虚函数
    + 派生链
- C++ 延迟|动态链接吗？
    - 方法未定义，直接客户端调用 undefined；不调用，即使是未定义，no problem

- 面向对象
    + 编译器生成的成员函数： 默认构造函数 | 复制构造函数 && 赋值运算符重载 | 
    + 构造函数
        - 析构函数 成对[基类析构函数是虚的]
        - 构造转换函数 <- 类型之间自动转换 || 强制转换 <- explict 禁止隐式转换
        - 转换其他类型 -> 成员函数
    - 按值传递 || 按引用传递 -> 虚函数 || 纯虚函数[返回引用|值]
        + 虚函数表，实现引用|指针根据对象进行动态绑定 || 晚期加载
        + 编译器 || 连接器实现细节问题
    + is a = 公有继承 || has a = 私有继承
        - 私有继承，可访问 protected 成员 || 可重新定义虚函数[相比共有集成]
        - 通用：公有继承，更容易理解与使用
        - 多重继承问题：虚基类
        - 
    + 友元可访问私有-保护成员,实现原理？
+ 异常机制
    - 程序崩溃[abort]
    - 引发异常[throw] || 处理异常[catch]
    -         
- C++11 -> C20特性
    + 练手项目足够熟悉！
    + 面试本质： 自身足够熟悉 - 了解 | 熟悉细节 | 精通-原理，实现

- 钻研，创新，更深一层[optional] - 程度根据市场反馈：投入精力资源比重！
    + 编程社区
    + 


