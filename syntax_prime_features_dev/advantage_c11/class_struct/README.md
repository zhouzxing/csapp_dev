# 手写数据结构
> 练习算法

## 熟悉C11高级特性
- 复合数据类型|派生类型[熟悉实现原理]-不只是使用，自创！
    + string - char[] |数组[栈]
    + array[栈]
    + vector : new|delete 时机与原理[堆]
    + 
- 类型转换[11 + 3]
    - bool + char short int long (long long) [unsigned | signed] = 1 + 5*2
    - float double long double
    - 列表初始化注意事项：
        - 列表初始化不允许缩窄
        - {X} : X必须是常量
    - 自动初始化
        - bool char[unsigened char/signed char] short --> int
        - if : short<int ,则 unsigned short -> unsigned int
        - 实现原理： 校验表[8条规则]
            - 有/无符号整数级别： long long > long > int > short > signed char
            - 强制类型转换：创建一个新的指定类型的值 ； 不修改原值
            - 
    - 转换规则
        + 提升转换
        + 标准转换
        + 用户定义的转换
- 友元函数 | 虚函数&纯虚函数
    + 友元函数，继承前提：重载？
    + 

- 编译器不检查错误
    + 数组越界错误[不安全] -> string | vector
        + vector | array :at() 支持运行时捕获索引越界
    - 

- OOP > 面向过程
    + 分配内存等 推迟到 运行时进行决策[灵活]
    + 
- 内存管理
    + 堆栈的区别：栈-静态联编-sizeof | 堆不支持sizeof
        + sizeof 数组名[非地址]：数组长度 ； sizeof 指向数组指针：指针大小
        + 数组名：地址 = 指针
        + 字符串数组 ： strncpy | strcpy（） || 其他
    + 堆：内存池
        - 动态存储: [堆-内存池] - 内存泄漏问题：程序崩溃 | OS其他程序崩溃
        - 静态存储：static | 函数外部 [静态存储区]
        - 自动存储：[栈]
    + 数组 | 类 | 结构体 存储位置
        - 函数参数 | 返回值 - 按值传递[参量-参数]
            - 数组：本质是数组首地址，即指针
                + 传参: int[] arr [const] 
                    - 不支持 sizeof arr[数组声明的数组名：sizeof arr = 数组的总长度]
                    - 但如果： int* arr, 支持 sizeof arr
                    - 所以：数组的长度必须是传进来的！
                + 传参：int* start,int* end[函数参数不支持：完全数组，如：二维数组，传错为：指针数组] - 数组不支持赋值数组
                + 返回值：数组本身没必要返回 
                    - 特定业务：arr+1 ,等非首地址

            - 字符串 & char[]
                + 字符串默认：结束符：'\0'
                + 传参： char* p
                + 返回值：char* -> 必须 new出来，存在于堆上，[可见性] + delete

            - 结构体支持 赋值运算 || string -“整体”
                + 传参：引用，指针 ， 值传递
                + 返回值：指针[堆]，值传递, void
        > 数组：指针，结构体：引用|指针；类：引用 [内置数据类型：修改使用指针，否则值传递]
        - 自动类型推断
            + 仅支持 单值初始化，不支持 列表初始化
            + 二维数组 或者 一维数组的地址 ： 指向指针的指针 || 指向函数指针的指针适用更广泛
    - 变量持续性[9]
        - 
        - 
- 函数模板
    - 函数调用原理—堆栈[栈内变量表]+[堆] & 指令调用地址
    - 内联函数 > typedef [简单替换问题]
    - 引用变量 - 函数形参-结构|类的引用，变量别名
        + 声明引用同时：初始化
        + 类似：const 指针
        + 传参 + 返回值：实现类似lambda
        + 右值引用
            - 库设计
    - 默认参数函数 | 重载[函数多态]-类多态 
        + 最佳匹配：如果出现：const size_t &v | size_t& v | size_t &&v
    - 模板[泛型]
        + 支持重载模板
        + 重载运算符：特定结果或者类 || 特定类：具体化模板定义[显式具体化]
        + 非模板函数 > 显式具体化 > 常规模板
        + 显式实例化 || 显示具体化
            - template fun<Size_t>() [显示实例化]
            - template<> fun<Size_t>() []
        + const | 非const 区别： 仅适用 指针与引用 ，再选择最佳匹配函数时候[部分排序规则]
        + decltype:支持 类型一致

## 类 | 友元 | 异常
> 抽象 | 封装和数据隐藏 | 多态 | 继承 | 代码的可重用性
- 类基础[设计思路：oop | 面向过程]
    - 类作用域
- 多态[运算符重载] 
    - 有效运算符：
        + 有效： = （） [] -> ....
        + 重载运算符：不必是成员函数，但至少有一个操作数是用户定义的类型
        + 不可重载的运算符：
            - sizeof || . || ->  || :: || ? :
- 友元
    - 友元函数 | 类 | 成员函数
    - 友元函数：两种不同类型运算
        + 实现 常规非成员函数不能访问私有数据的限制
        + 类声明中声明，但不是成员函数
        + 定义：不需要 Class:: 限定符
        + 类的扩展接口 - 友元实现访问私有对象

- 自动转换|强制类型转换
    + 构造函数只有一个基本类型变量[转换函数+赋值运算符 == 复制构造]
    + 或者其他参数有默认值，存在一个参数无默认值
    + explict 支持关闭自动隐式转换
    + 转换函数
        - operator typeName();
        - 类方法 | 无返回值 | 无参数
        - 
- 类|动态内存分配
    + 涉及 new\delete -> 析构函数 | 赋值运算符 | 复制构造
    + 静态数据成员：在定义文件中初始化，防止多个.h头文件导致的多副本
        - 特例：static const int 整型 ||static const enum枚举型
    + 

## 标准库-C++11


## QA
- 命名空间如何实现不同例库包含
    + 编译指令
    + translation unit[最好：同一编译器编译链接]

- 右值引用
    - 库代码
    - 
- 返回值：临时变量处理逻辑
    + 寄存器等 临时内存单元    
- CPP编译器
    + warings & error 区别 Java - warn可以过[异常处理机制]
        + warning：
            + 函数返回内部临时变量的引用
        - error: 
            + segment error
            + 语法错误： sizeof T 忘记括号
## 总结
- 类名：首字母大写
    - 默认对象访问控制：private || 结构默认：public - 数据对象
    - 作用域解析符 :: 
    - 类方法：所有对象共享 || 成员则是单独
        - 客户端了解 接口功能即可！[实现细节另说]
        -
    - 数据隐藏：数据部分均为私有
        - 成员名称：后缀_ || 前缀m_
    - 构造函数
        - 默认构造函数-无参，编译器提供
        - 用户定义过，必须提供默认构造[否则：Class c//失败]
        + const 成员函数 
    - 析构函数
        - 没有参数，也不需要：处理成员变量
        - 调用时机：编译器根据 类声明的类型进行回收！
    - 创建类
        - Class a() || Class a = Class() || Class a = {} == Class a{}
        - Class* p_c = new Class()
        + 如果构造函数存在只有一个参数 ： Class b = n; //临时对象
        - 对象数组
        + ADT
    
- 多翻译单元[文件]|内存管理
    - 存储持续性
        - 自动存储持续性:函数内定义[栈]
        - 静态存储持续性：static[函数外定义] - 字符串常量
        - 线程存储持续性：thread_local
        - 动态存储持续性：new[堆]
    - 链接性[单元间共享]
    - 作用域
        - 局部|全局|名称空间|函数原型
    - 场景：
        - 函数：自动局部无连接
            - auto 自动变量
            - 寄存器变量
        - 静态存储持续性
            - 外部 | 内部 | 无连接
            - 编译器分配固定的内存块：[静态存储区] 
                - 初始化默认值 0...
                - 常量初始化：常量表达式初始化
                - 动态初始化：涉及到 链接其他库的时候
            - 函数
                - 默认是外部连结性
                - 支持static 约束内部链接
                - 编译器查找原则：根据链接性；程序文件 -》 库 搜索
            - 语言链接性，c|c++
                - 对函数定位：名称不同，查找函数名
            - 动态分配：new|delete
                - 支持自定义替换函数-进行内存管理
                - 定位运算符new
            - 名称空间
                - 声明区域-潜在声明区域->可见域[局部变量覆盖]
                - 名称空间，支持：定义，添加
                    - using声明 | using编译指令使所有名称可用
                    - 
        - CV:
            - auto | register
            - static | extern
            - thread_local
            - cosnt | volatile[易变]
                - const :默认是内部链接静态变量
                - extern const 实现外部声明与初始化
            - mutable:对常量结构的某个字段可变更
            